import { watch as J, unref as T, getCurrentScope as De, onScopeDispose as Q, ref as z, onMounted as Ze, nextTick as Lt, onBeforeUnmount as et, renderSlot as an, isVNode as ln, Comment as fn, createTextVNode as un, Fragment as dn, readonly as Bt, toRef as hn, computed as W, isRef as Oe, customRef as mn, reactive as qe, shallowRef as Ie, watchEffect as lt } from "vue";
const D = typeof window < "u";
var ft;
D && ((ft = window == null ? void 0 : window.navigator) != null && ft.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Xe(e) {
  return e != null;
}
function P() {
}
const pn = Object.freeze({
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
});
Object.freeze(new Set(Object.keys(pn)));
function ut(e) {
  return e & -e;
}
function vn(e, t = 0) {
  const n = new Array(e + 1).fill(0);
  function r(c, a) {
    if (!(!a || c >= e))
      for (c += 1; c <= e; )
        n[c] += a, c += ut(c);
  }
  function o(c = e) {
    if (c <= 0)
      return 0;
    c > e && (c = e);
    let a = c * t;
    for (; c > 0; )
      a += n[c], c -= ut(c);
    return a;
  }
  function i(c) {
    return o(c + 1) - o(c);
  }
  function s(c) {
    let a = 0, l = e;
    for (; l > a; ) {
      const f = Math.floor((a + l) / 2), p = o(f);
      if (p > c) {
        l = f;
        continue;
      } else if (p < c) {
        if (a === f)
          return o(a + 1) <= c ? a + 1 : a;
        a = f;
      } else
        return f;
    }
    return a;
  }
  return { tree: n, add: r, sum: o, get: i, boundIndex: s };
}
function gn(e) {
  let t = parseFloat(e);
  return Number.isNaN(t) && (t = Number(e)), Number.isNaN(t) ? 0 : t;
}
const bn = D && ("ontouchstart" in window || wn() > 0), yn = bn ? "pointerdown" : "click";
function wn() {
  return typeof navigator < "u" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;
}
function xn(e, t, n = window.Event) {
  const { type: r, bubbles: o = !1, cancelable: i = !1, ...s } = t;
  if (!Xe(r) || r === "")
    return !1;
  let c;
  return Xe(n) ? c = new n(r, { bubbles: o, cancelable: i }) : (c = document.createEvent("HTMLEvents"), c.initEvent(r, o, i)), Object.assign(c, s), e.dispatchEvent(c);
}
const En = D ? requestAnimationFrame : (e) => {
  setTimeout(e, 16);
};
function Pt(e, t = 16) {
  if (typeof e != "function")
    return P;
  const n = (...i) => {
    e(...i);
  };
  if (t <= 0)
    return Rn(n);
  let r = 0, o;
  return function(...i) {
    const s = Date.now(), c = s - r;
    clearTimeout(o), c >= t ? (r = s, n(...i)) : o = setTimeout(
      () => {
        r = Date.now(), n(...i);
      },
      Math.max(0, t - c)
    );
  };
}
function Rn(e) {
  if (typeof e != "function")
    return e;
  let t = !1, n, r;
  return function(...o) {
    return n = o, t || (t = !0, r = Promise.resolve().then(() => (t = !1, r = void 0, e(...n)))), r;
  };
}
const he = /* @__PURE__ */ new Set(), Dt = /* @__PURE__ */ new WeakMap();
function Tn() {
  he.forEach((e) => {
    e(...Dt.get(e));
  }), he.clear();
}
function Sn(e, ...t) {
  if (typeof e != "function")
    return e;
  Dt.set(e, t), !he.has(e) && (he.add(e), he.size === 1 && En(Tn));
}
function Ft(e) {
  return Array.isArray(e) ? e : [e];
}
function V(e, t, n, r) {
  if (!e)
    return P;
  let o = P;
  const i = J(
    () => T(e),
    (c) => {
      o(), c && (c.addEventListener(t, n, r), o = () => {
        c.removeEventListener(t, n, r), o = P;
      });
    },
    { immediate: !0, flush: "post" }
  ), s = () => {
    i(), o();
  };
  return De() && Q(s), s;
}
const _t = "clickoutside", je = /* @__PURE__ */ new Set();
D && document.addEventListener(
  yn,
  (e) => {
    const t = e.target, n = e.composedPath && e.composedPath();
    je.forEach((r) => {
      r !== t && (n ? !n.includes(r) : !r.contains(t)) && (!r.__transferElement || r.__transferElement !== t && !r.__transferElement.contains(t)) && xn(r, { type: _t });
    });
  },
  !0
);
function Yr(e, t = z(null)) {
  let n = P;
  const r = J(
    () => T(t),
    (i) => {
      n(), i && (je.add(i), n = () => {
        je.delete(i), n = P;
      });
    },
    { immediate: !0, flush: "post" }
  ), o = () => {
    r(), n();
  };
  return De() && Q(o), V(t, _t, e), t;
}
function Kr(e = P, t = z(null)) {
  let n;
  return Ze(() => {
    Lt(() => {
      const r = Nt(t.value);
      r ? (n = new MutationObserver(() => {
        r.style.display !== "none" && (typeof e == "function" && e(), n == null || n.disconnect(), n = null);
      }), n.observe(r, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        attributeFilter: ["style"]
      })) : typeof e == "function" && e();
    });
  }), et(() => {
    n == null || n.disconnect(), n = null;
  }), t;
}
function Nt(e) {
  if (e) {
    let t = e.parentElement;
    for (; t && t !== document.body; ) {
      if (t.style.display === "none")
        return t;
      t = t.parentElement;
    }
  }
  return null;
}
function dt(e) {
  return (e == null ? void 0 : e.style.display) !== "none" ? !!Nt(e) : !0;
}
function Ur(e, t, n) {
  for (const r of t)
    if (e[r])
      return (o) => an(e, r, o, () => {
        const i = n == null ? void 0 : n(o);
        return i ? Ft(i) : [];
      });
  return n || null;
}
function Gr(e) {
  const t = [], n = Array.isArray(e) ? [...e] : [];
  for (; n.length; ) {
    const r = n.shift();
    r !== null && (Array.isArray(r) && n.unshift(...r), !(typeof r != "string" && typeof r != "number" && (!ln(r) || r.type === fn)) && (typeof r == "string" || typeof r == "number" ? t.push(un(String(r))) : r.type === dn && Array.isArray(r.children) ? n.unshift(r.children) : t.push(r)));
  }
  return t;
}
function we(e) {
  const t = T(e);
  return typeof t == "string" ? D ? document.querySelector(t) : null : (t == null ? void 0 : t.$el) ?? t;
}
function Jr(e) {
  return new Proxy({}, {
    get(t, n) {
      var r, o, i;
      if (e.component)
        return ((r = e.component.proxy) == null ? void 0 : r[n]) ?? ((o = e.component.exposeProxy) == null ? void 0 : o[n]) ?? ((i = e.component.exposed) == null ? void 0 : i[n]);
    }
  });
}
function Qr(...e) {
  const t = z(!0), n = e[1] || P;
  function r() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = J(
    e[0],
    (...s) => new Promise((c, a) => {
      t.value && Promise.resolve(n(...s)).then(c).catch(a);
    }),
    e[2]
  );
  return { active: Bt(t), pause: r, resume: o, stop: i };
}
function Zr(e, t) {
  return t.map((n) => hn(e, n));
}
const On = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
let ie;
if (D) {
  for (const e of On)
    if (e[1] in document) {
      ie = e;
      break;
    }
}
const Ye = !!ie, kn = {
  supported: Ye,
  full: W(() => !1),
  enter: P,
  exit: P,
  toggle: P
}, Wt = /* @__PURE__ */ new Set(), Ke = /* @__PURE__ */ new WeakMap();
if (D && ie) {
  const e = ie[2], t = ie[4];
  document.addEventListener(
    t,
    () => {
      if (Wt.forEach((n) => {
        n.value = !1;
      }), document[e]) {
        const n = Ke.get(document[e]);
        n && (n.value = !0);
      }
    },
    !1
  );
}
function eo(e = z(null)) {
  const t = W({
    get: () => we(e),
    set: (l) => {
      Oe(e) && (e.value = l);
    }
  });
  if (!D || !Ye)
    return { ...kn, target: t };
  const [n, r, o] = ie, i = z(!1);
  J(
    () => we(e),
    (l, f) => {
      f && Ke.delete(f), l && Ke.set(l, i);
    },
    { immediate: !0, flush: "post" }
  ), Wt.add(i), De() && Q(c);
  async function s(l = !1) {
    await c();
    const f = we(e);
    return f && (l || !document[o]) ? (await f[n](), i.value = !0, document[o] === f) : !1;
  }
  async function c(l = !1) {
    const f = we(e);
    return l || document[o] && document[o] === f ? (await document[r](), i.value = !1, document[o] !== f) : !1;
  }
  async function a(l = !1) {
    return i.value ? await c(l) : await s(l);
  }
  return {
    supported: Ye,
    target: t,
    full: W(() => i.value),
    enter: s,
    exit: c,
    toggle: a
  };
}
function to(e = z(null)) {
  const t = z(!1);
  V(e, "mouseenter", n), V(e, "mouseleave", r);
  function n() {
    t.value = !0;
  }
  function r() {
    t.value = !1;
  }
  return { wrapper: e, isHover: t };
}
const xe = /* @__PURE__ */ new WeakMap(), zn = /\s+/g, Cn = /(px|%)$/;
function no(e) {
  const t = e.target || z(null);
  if (!D)
    return { target: t, disconnect: P };
  const { handler: n } = e;
  let r = e.root ?? document;
  const o = Ft(e.threshold || 0).join() || "0", i = m(e.rootMargin);
  xe.has(r) || xe.set(r, /* @__PURE__ */ new Map());
  const s = xe.get(r);
  s.has(o) || s.set(o, /* @__PURE__ */ new Map());
  const c = s.get(o);
  c.has(i) || c.set(i, {
    ob: new IntersectionObserver(v, { ...e, rootMargin: i }),
    count: 0,
    handlers: /* @__PURE__ */ new WeakMap()
  });
  let a = c.get(i), { ob: l, handlers: f } = a, p = P;
  const b = J(
    () => T(t),
    (d) => {
      p(), !(!d || !l) && (f.set(d, n), l.observe(d), a && a.count++, p = () => {
        l.unobserve(d), f.delete(d), a && a.count--, p = P;
      });
    },
    { immediate: !0, flush: "post" }
  );
  De() && Q(u);
  function m(d) {
    if (!d || !d.trim())
      return "_";
    const h = d.trim().split(zn, 4);
    h.length = 4;
    for (let g = 0; g < 4; ++g) {
      const w = h[g];
      h[g] = Cn.test(w) ? w : `${gn(w)}px`;
    }
    return h.join(" ");
  }
  function v(d) {
    for (let h = 0, g = d.length; h < g; ++h) {
      const w = d[h], O = f.get(w.target);
      typeof O == "function" && O(w);
    }
  }
  function u() {
    b(), p(), a && (a.count <= 0 && (c.delete(i), c.size || (s.delete(o), s.size || xe.delete(r))), a = void 0, l = void 0, f = void 0, r = void 0);
  }
  return { target: t, disconnect: u };
}
function ro() {
  const e = /* @__PURE__ */ new Set();
  function t(r) {
    return mn((o, i) => {
      let s = r;
      const c = () => {
        r !== s && (s = r, i());
      };
      return {
        get: () => (o(), r),
        set: (a) => {
          a !== r && (r = a, e.add(c));
        }
      };
    });
  }
  function n() {
    for (const r of e)
      r();
    e.clear();
  }
  return { updateSet: e, manualRef: t, triggerUpdate: n };
}
const An = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
}, Mn = /[+_-]/, Ln = /[+_-]/g, Bn = ["activeKeys", "resetAll"];
function oo(e = {}) {
  const {
    autoReset: t = !0,
    capture: n = !1,
    passive: r = !0,
    onKeyDown: o = P,
    onKeyUp: i = P
  } = e, s = e.target || z(null), c = { ...An, ...e.aliasMap || {} }, a = qe(/* @__PURE__ */ new Set()), l = /* @__PURE__ */ new Set(), f = qe({ activeKeys: a, resetAll: m });
  function p(u, d) {
    u in f && (f[u] = d);
  }
  function b(u, d) {
    var O, S;
    const h = (O = u.key) == null ? void 0 : O.toLocaleLowerCase(), w = [(S = u.code) == null ? void 0 : S.toLocaleLowerCase(), h].filter(Boolean);
    for (const R of w)
      a[d ? "add" : "delete"](R), p(R, d);
    if (!d && h === "meta") {
      for (const R of l)
        a.delete(R), p(R, !1);
      l.clear();
    } else if (d && typeof u.getModifierState == "function" && u.getModifierState("Meta"))
      for (const R of [...a, ...w])
        l.add(R);
  }
  function m() {
    Object.keys(f).forEach((u) => {
      f[u] = !1;
    }), f.activeKeys = a, f.resetAll = m;
  }
  const v = new Proxy(f, {
    get(u, d, h) {
      if (typeof d != "string" || Bn.includes(d))
        return Reflect.get(u, d, h);
      if (d = d.toLocaleLowerCase(), d in c && (d = c[d]), !(d in f))
        if (Mn.test(d)) {
          const g = d.split(Ln).map((w) => w.trim());
          f[d] = W(() => g.every((w) => T(v[w])));
        } else
          f[d] = z(a.has(d));
      return T(Reflect.get(u, d, h));
    }
  });
  return V(
    s,
    "keydown",
    (u) => {
      b(u, !0), o(u, v);
    },
    { capture: n, passive: r }
  ), V(
    s,
    "keyup",
    (u) => {
      b(u, !1), i(u, v);
    },
    { capture: n, passive: r }
  ), t && V(s, "blur", m, { capture: n, passive: r }), { target: s, modifier: v };
}
function io(e) {
  const t = z(!1), n = () => t.value = !0;
  return Ze(() => {
    e === "tick" ? Lt(n) : e === "frame" ? requestAnimationFrame(n) : n();
  }), et(() => {
    t.value = !1;
  }), { isMounted: Bt(t) };
}
function He(e) {
  e.cancelable && (e.stopPropagation(), e.preventDefault());
}
function so(e) {
  const t = e.target || z(null), n = Oe(e.x) ? e.x : z(0), r = Oe(e.y) ? e.y : z(0), o = Oe(e.lazy) ? e.lazy : z(!1), { capture: i = !0, stopMouse: s = !0, stopTouch: c = !0 } = e, a = z(!1), l = {
    xStart: 0,
    yStart: 0,
    xEnd: 0,
    yEnd: 0,
    clientX: 0,
    clientY: 0,
    deltaX: 0,
    deltaY: 0,
    lazy: !1
  };
  let f = 0, p = 0;
  const b = Pt((h) => {
    var g;
    p < f || (d(h), l.lazy || (n.value = l.xEnd, r.value = l.yEnd), (g = e.onMove) == null || g.call(e, l, h));
  });
  function m(h) {
    var g;
    Object.assign(l, {
      xStart: n.value,
      yStart: r.value,
      xEnd: n.value,
      yEnd: r.value,
      clientX: h.clientX,
      clientY: h.clientY,
      lazy: o.value
    }), ((g = e.onStart) == null ? void 0 : g.call(e, l, h)) !== !1 && (document.addEventListener("pointermove", v, { capture: i }), document.addEventListener("pointerup", u, { capture: i }), p = f, a.value = !0);
  }
  function v(h) {
    He(h), b(h);
  }
  function u(h) {
    var g;
    document.removeEventListener("pointermove", v, { capture: i }), document.removeEventListener("pointerup", u, { capture: i }), d(h), l.lazy && (n.value = l.xEnd, r.value = l.yEnd), a.value = !1, ++f, (g = e.onEnd) == null || g.call(e, l, h);
  }
  function d(h) {
    const { clientX: g, clientY: w } = h, { xStart: O, yStart: S, clientX: R, clientY: M } = l, A = g - R, B = w - M;
    l.deltaX = A, l.deltaY = B, l.xEnd = O + A, l.yEnd = S + B;
  }
  return V(t, "pointerdown", m, { capture: i }), s && V(t, "mousedown", He, { capture: i }), c && V(t, "touchstart", He, { capture: i }), {
    target: t,
    moving: W(() => a.value),
    x: n,
    y: r,
    lazy: o
  };
}
const pe = /* @__PURE__ */ new Set(), K = /* @__PURE__ */ new Map();
K.set("x", 0);
K.set("y", 0);
function Pn(e) {
  const { pageX: t, pageY: n } = e;
  K.set("x", t), K.set("y", n), pe.forEach((r) => {
    r.x.value = t, r.y.value = n;
  });
}
const It = Pt(Pn);
function Dn(e) {
  !pe.size && window && (K.set("x", 0), K.set("y", 0), window.addEventListener("pointermove", It, { passive: !0 })), pe.add(e);
}
function ht(e) {
  pe.delete(e), !pe.size && window && window.removeEventListener("pointermove", It);
}
function co(e = {}) {
  const t = z(e.x ?? K.get("x")), n = z(e.y ?? K.get("y")), r = { x: t, y: n };
  return Dn(r), e.manualStop || et(() => {
    ht(r);
  }), { ...r, unregister: () => ht(r) };
}
const Fn = ["top", "right", "bottom", "left"], ae = Math.min, ee = Math.max, Ce = Math.round, Ee = Math.floor, U = (e) => ({
  x: e,
  y: e
}), _n = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Nn = {
  start: "end",
  end: "start"
};
function Ue(e, t, n) {
  return ee(e, ae(t, n));
}
function fe(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function re(e) {
  return e.split("-")[0];
}
function be(e) {
  return e.split("-")[1];
}
function Ht(e) {
  return e === "x" ? "y" : "x";
}
function tt(e) {
  return e === "y" ? "height" : "width";
}
function Fe(e) {
  return ["top", "bottom"].includes(re(e)) ? "y" : "x";
}
function nt(e) {
  return Ht(Fe(e));
}
function Wn(e, t, n) {
  n === void 0 && (n = !1);
  const r = be(e), o = nt(e), i = tt(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = Ae(s)), [s, Ae(s)];
}
function In(e) {
  const t = Ae(e);
  return [Ge(e), t, Ge(t)];
}
function Ge(e) {
  return e.replace(/start|end/g, (t) => Nn[t]);
}
function Hn(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function $n(e, t, n, r) {
  const o = be(e);
  let i = Hn(re(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(Ge)))), i;
}
function Ae(e) {
  return e.replace(/left|right|bottom|top/g, (t) => _n[t]);
}
function Vn(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function $t(e) {
  return typeof e != "number" ? Vn(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Me(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function mt(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = Fe(t), s = nt(t), c = tt(s), a = re(t), l = i === "y", f = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, b = r[c] / 2 - o[c] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: f,
        y: r.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (be(t)) {
    case "start":
      m[s] -= b * (n && l ? -1 : 1);
      break;
    case "end":
      m[s] += b * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const qn = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: f,
    y: p
  } = mt(l, r, a), b = r, m = {}, v = 0;
  for (let u = 0; u < c.length; u++) {
    const {
      name: d,
      fn: h
    } = c[u], {
      x: g,
      y: w,
      data: O,
      reset: S
    } = await h({
      x: f,
      y: p,
      initialPlacement: r,
      placement: b,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (f = g ?? f, p = w ?? p, m = {
      ...m,
      [d]: {
        ...m[d],
        ...O
      }
    }, S && v <= 50) {
      v++, typeof S == "object" && (S.placement && (b = S.placement), S.rects && (l = S.rects === !0 ? await s.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : S.rects), {
        x: f,
        y: p
      } = mt(l, b, a)), u = -1;
      continue;
    }
  }
  return {
    x: f,
    y: p,
    placement: b,
    strategy: o,
    middlewareData: m
  };
};
async function Le(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: p = "floating",
    altBoundary: b = !1,
    padding: m = 0
  } = fe(t, e), v = $t(m), d = c[b ? p === "floating" ? "reference" : "floating" : p], h = Me(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(d))) == null || n ? d : d.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: f,
    strategy: a
  })), g = p === "floating" ? {
    ...s.floating,
    x: r,
    y: o
  } : s.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), O = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Me(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: g,
    offsetParent: w,
    strategy: a
  }) : g);
  return {
    top: (h.top - S.top + v.top) / O.y,
    bottom: (S.bottom - h.bottom + v.bottom) / O.y,
    left: (h.left - S.left + v.left) / O.x,
    right: (S.right - h.right + v.right) / O.x
  };
}
const Xn = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: c,
      middlewareData: a
    } = t, {
      element: l,
      padding: f = 0
    } = fe(e, t) || {};
    if (l == null)
      return {};
    const p = $t(f), b = {
      x: n,
      y: r
    }, m = nt(o), v = tt(m), u = await s.getDimensions(l), d = m === "y", h = d ? "top" : "left", g = d ? "bottom" : "right", w = d ? "clientHeight" : "clientWidth", O = i.reference[v] + i.reference[m] - b[m] - i.floating[v], S = b[m] - i.reference[m], R = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let M = R ? R[w] : 0;
    (!M || !await (s.isElement == null ? void 0 : s.isElement(R))) && (M = c.floating[w] || i.floating[v]);
    const A = O / 2 - S / 2, B = M / 2 - u[v] / 2 - 1, F = ae(p[h], B), N = ae(p[g], B), L = F, y = M - u[v] - N, x = M / 2 - u[v] / 2 + A, E = Ue(L, x, y), C = !a.arrow && be(o) != null && x != E && i.reference[v] / 2 - (x < L ? F : N) - u[v] / 2 < 0, k = C ? x < L ? x - L : x - y : 0;
    return {
      [m]: b[m] + k,
      data: {
        [m]: E,
        centerOffset: x - E - k,
        ...C && {
          alignmentOffset: k
        }
      },
      reset: C
    };
  }
}), jn = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: f = !0,
        crossAxis: p = !0,
        fallbackPlacements: b,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: u = !0,
        ...d
      } = fe(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const h = re(o), g = re(c) === c, w = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), O = b || (g || !u ? [Ae(c)] : In(c));
      !b && v !== "none" && O.push(...$n(c, u, v, w));
      const S = [c, ...O], R = await Le(t, d), M = [];
      let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (f && M.push(R[h]), p) {
        const L = Wn(o, s, w);
        M.push(R[L[0]], R[L[1]]);
      }
      if (A = [...A, {
        placement: o,
        overflows: M
      }], !M.every((L) => L <= 0)) {
        var B, F;
        const L = (((B = i.flip) == null ? void 0 : B.index) || 0) + 1, y = S[L];
        if (y)
          return {
            data: {
              index: L,
              overflows: A
            },
            reset: {
              placement: y
            }
          };
        let x = (F = A.filter((E) => E.overflows[0] <= 0).sort((E, C) => E.overflows[1] - C.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!x)
          switch (m) {
            case "bestFit": {
              var N;
              const E = (N = A.map((C) => [C.placement, C.overflows.filter((k) => k > 0).reduce((k, j) => k + j, 0)]).sort((C, k) => C[1] - k[1])[0]) == null ? void 0 : N[0];
              E && (x = E);
              break;
            }
            case "initialPlacement":
              x = c;
              break;
          }
        if (o !== x)
          return {
            reset: {
              placement: x
            }
          };
      }
      return {};
    }
  };
};
function pt(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function vt(e) {
  return Fn.some((t) => e[t] >= 0);
}
const Yn = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = fe(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await Le(t, {
            ...o,
            elementContext: "reference"
          }), s = pt(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: vt(s)
            }
          };
        }
        case "escaped": {
          const i = await Le(t, {
            ...o,
            altBoundary: !0
          }), s = pt(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: vt(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function Kn(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = re(n), c = be(n), a = Fe(n) === "y", l = ["left", "top"].includes(s) ? -1 : 1, f = i && a ? -1 : 1, p = fe(t, e);
  let {
    mainAxis: b,
    crossAxis: m,
    alignmentAxis: v
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...p
  };
  return c && typeof v == "number" && (m = c === "end" ? v * -1 : v), a ? {
    x: m * f,
    y: b * l
  } : {
    x: b * l,
    y: m * f
  };
}
const Un = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: c
      } = t, a = await Kn(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, Gn = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (d) => {
            let {
              x: h,
              y: g
            } = d;
            return {
              x: h,
              y: g
            };
          }
        },
        ...a
      } = fe(e, t), l = {
        x: n,
        y: r
      }, f = await Le(t, a), p = Fe(re(o)), b = Ht(p);
      let m = l[b], v = l[p];
      if (i) {
        const d = b === "y" ? "top" : "left", h = b === "y" ? "bottom" : "right", g = m + f[d], w = m - f[h];
        m = Ue(g, m, w);
      }
      if (s) {
        const d = p === "y" ? "top" : "left", h = p === "y" ? "bottom" : "right", g = v + f[d], w = v - f[h];
        v = Ue(g, v, w);
      }
      const u = c.fn({
        ...t,
        [b]: m,
        [p]: v
      });
      return {
        ...u,
        data: {
          x: u.x - n,
          y: u.y - r
        }
      };
    }
  };
};
function G(e) {
  return Vt(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function _(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function X(e) {
  var t;
  return (t = (Vt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Vt(e) {
  return e instanceof Node || e instanceof _(e).Node;
}
function q(e) {
  return e instanceof Element || e instanceof _(e).Element;
}
function $(e) {
  return e instanceof HTMLElement || e instanceof _(e).HTMLElement;
}
function gt(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof _(e).ShadowRoot;
}
function ye(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = I(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function Jn(e) {
  return ["table", "td", "th"].includes(G(e));
}
function rt(e) {
  const t = ot(), n = I(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function Qn(e) {
  let t = le(e);
  for (; $(t) && !_e(t); ) {
    if (rt(t))
      return t;
    t = le(t);
  }
  return null;
}
function ot() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function _e(e) {
  return ["html", "body", "#document"].includes(G(e));
}
function I(e) {
  return _(e).getComputedStyle(e);
}
function Ne(e) {
  return q(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function le(e) {
  if (G(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    gt(e) && e.host || // Fallback.
    X(e)
  );
  return gt(t) ? t.host : t;
}
function qt(e) {
  const t = le(e);
  return _e(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : $(t) && ye(t) ? t : qt(t);
}
function ve(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = qt(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = _(o);
  return i ? t.concat(s, s.visualViewport || [], ye(o) ? o : [], s.frameElement && n ? ve(s.frameElement) : []) : t.concat(o, ve(o, [], n));
}
function Xt(e) {
  const t = I(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = $(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, c = Ce(n) !== i || Ce(r) !== s;
  return c && (n = i, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function it(e) {
  return q(e) ? e : e.contextElement;
}
function se(e) {
  const t = it(e);
  if (!$(t))
    return U(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = Xt(t);
  let s = (i ? Ce(n.width) : n.width) / r, c = (i ? Ce(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const Zn = /* @__PURE__ */ U(0);
function jt(e) {
  const t = _(e);
  return !ot() || !t.visualViewport ? Zn : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function er(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== _(e) ? !1 : t;
}
function oe(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = it(e);
  let s = U(1);
  t && (r ? q(r) && (s = se(r)) : s = se(e));
  const c = er(i, n, r) ? jt(i) : U(0);
  let a = (o.left + c.x) / s.x, l = (o.top + c.y) / s.y, f = o.width / s.x, p = o.height / s.y;
  if (i) {
    const b = _(i), m = r && q(r) ? _(r) : r;
    let v = b.frameElement;
    for (; v && r && m !== b; ) {
      const u = se(v), d = v.getBoundingClientRect(), h = I(v), g = d.left + (v.clientLeft + parseFloat(h.paddingLeft)) * u.x, w = d.top + (v.clientTop + parseFloat(h.paddingTop)) * u.y;
      a *= u.x, l *= u.y, f *= u.x, p *= u.y, a += g, l += w, v = _(v).frameElement;
    }
  }
  return Me({
    width: f,
    height: p,
    x: a,
    y: l
  });
}
function tr(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const o = $(n), i = X(n);
  if (n === i)
    return t;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = U(1);
  const a = U(0);
  if ((o || !o && r !== "fixed") && ((G(n) !== "body" || ye(i)) && (s = Ne(n)), $(n))) {
    const l = oe(n);
    c = se(n), a.x = l.x + n.clientLeft, a.y = l.y + n.clientTop;
  }
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - s.scrollLeft * c.x + a.x,
    y: t.y * c.y - s.scrollTop * c.y + a.y
  };
}
function nr(e) {
  return Array.from(e.getClientRects());
}
function Yt(e) {
  return oe(X(e)).left + Ne(e).scrollLeft;
}
function rr(e) {
  const t = X(e), n = Ne(e), r = e.ownerDocument.body, o = ee(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = ee(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Yt(e);
  const c = -n.scrollTop;
  return I(r).direction === "rtl" && (s += ee(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: c
  };
}
function or(e, t) {
  const n = _(e), r = X(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, c = 0, a = 0;
  if (o) {
    i = o.width, s = o.height;
    const l = ot();
    (!l || l && t === "fixed") && (c = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
function ir(e, t) {
  const n = oe(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = $(e) ? se(e) : U(1), s = e.clientWidth * i.x, c = e.clientHeight * i.y, a = o * i.x, l = r * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function bt(e, t, n) {
  let r;
  if (t === "viewport")
    r = or(e, n);
  else if (t === "document")
    r = rr(X(e));
  else if (q(t))
    r = ir(t, n);
  else {
    const o = jt(e);
    r = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return Me(r);
}
function Kt(e, t) {
  const n = le(e);
  return n === t || !q(n) || _e(n) ? !1 : I(n).position === "fixed" || Kt(n, t);
}
function sr(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = ve(e, [], !1).filter((c) => q(c) && G(c) !== "body"), o = null;
  const i = I(e).position === "fixed";
  let s = i ? le(e) : e;
  for (; q(s) && !_e(s); ) {
    const c = I(s), a = rt(s);
    !a && c.position === "fixed" && (o = null), (i ? !a && !o : !a && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || ye(s) && !a && Kt(e, s)) ? r = r.filter((f) => f !== s) : o = c, s = le(s);
  }
  return t.set(e, r), r;
}
function cr(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? sr(t, this._c) : [].concat(n), r], c = s[0], a = s.reduce((l, f) => {
    const p = bt(t, f, o);
    return l.top = ee(p.top, l.top), l.right = ae(p.right, l.right), l.bottom = ae(p.bottom, l.bottom), l.left = ee(p.left, l.left), l;
  }, bt(t, c, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function ar(e) {
  return Xt(e);
}
function lr(e, t, n) {
  const r = $(t), o = X(t), i = n === "fixed", s = oe(e, !0, i, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = U(0);
  if (r || !r && !i)
    if ((G(t) !== "body" || ye(o)) && (c = Ne(t)), r) {
      const l = oe(t, !0, i, t);
      a.x = l.x + t.clientLeft, a.y = l.y + t.clientTop;
    } else
      o && (a.x = Yt(o));
  return {
    x: s.left + c.scrollLeft - a.x,
    y: s.top + c.scrollTop - a.y,
    width: s.width,
    height: s.height
  };
}
function yt(e, t) {
  return !$(e) || I(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function Ut(e, t) {
  const n = _(e);
  if (!$(e))
    return n;
  let r = yt(e, t);
  for (; r && Jn(r) && I(r).position === "static"; )
    r = yt(r, t);
  return r && (G(r) === "html" || G(r) === "body" && I(r).position === "static" && !rt(r)) ? n : r || Qn(e) || n;
}
const fr = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const o = this.getOffsetParent || Ut, i = this.getDimensions;
  return {
    reference: lr(t, await o(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await i(n)
    }
  };
};
function ur(e) {
  return I(e).direction === "rtl";
}
const Gt = {
  convertOffsetParentRelativeRectToViewportRelativeRect: tr,
  getDocumentElement: X,
  getClippingRect: cr,
  getOffsetParent: Ut,
  getElementRects: fr,
  getClientRects: nr,
  getDimensions: ar,
  getScale: se,
  isElement: q,
  isRTL: ur
};
function dr(e, t) {
  let n = null, r;
  const o = X(e);
  function i() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const {
      left: l,
      top: f,
      width: p,
      height: b
    } = e.getBoundingClientRect();
    if (c || t(), !p || !b)
      return;
    const m = Ee(f), v = Ee(o.clientWidth - (l + p)), u = Ee(o.clientHeight - (f + b)), d = Ee(l), g = {
      rootMargin: -m + "px " + -v + "px " + -u + "px " + -d + "px",
      threshold: ee(0, ae(1, a)) || 1
    };
    let w = !0;
    function O(S) {
      const R = S[0].intersectionRatio;
      if (R !== a) {
        if (!w)
          return s();
        R ? s(!1, R) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      w = !1;
    }
    try {
      n = new IntersectionObserver(O, {
        ...g,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(O, g);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function hr(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, l = it(e), f = o || i ? [...l ? ve(l) : [], ...ve(t)] : [];
  f.forEach((h) => {
    o && h.addEventListener("scroll", n, {
      passive: !0
    }), i && h.addEventListener("resize", n);
  });
  const p = l && c ? dr(l, n) : null;
  let b = -1, m = null;
  s && (m = new ResizeObserver((h) => {
    let [g] = h;
    g && g.target === l && m && (m.unobserve(t), cancelAnimationFrame(b), b = requestAnimationFrame(() => {
      m && m.observe(t);
    })), n();
  }), l && !a && m.observe(l), m.observe(t));
  let v, u = a ? oe(e) : null;
  a && d();
  function d() {
    const h = oe(e);
    u && (h.x !== u.x || h.y !== u.y || h.width !== u.width || h.height !== u.height) && n(), u = h, v = requestAnimationFrame(d);
  }
  return n(), () => {
    f.forEach((h) => {
      o && h.removeEventListener("scroll", n), i && h.removeEventListener("resize", n);
    }), p && p(), m && m.disconnect(), m = null, a && cancelAnimationFrame(v);
  };
}
const mr = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: Gt,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return qn(e, t, {
    ...o,
    platform: i
  });
};
var te = [], pr = function() {
  return te.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, vr = function() {
  return te.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, wt = "ResizeObserver loop completed with undelivered notifications.", gr = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: wt
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = wt), window.dispatchEvent(e);
}, ge;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ge || (ge = {}));
var ne = function(e) {
  return Object.freeze(e);
}, br = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, ne(this);
  }
  return e;
}(), Jt = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ne(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, c = t.left, a = t.width, l = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: c, width: a, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), st = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Qt = function(e) {
  if (st(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, xt = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, yr = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, me = typeof window < "u" ? window : {}, Re = /* @__PURE__ */ new WeakMap(), Et = /auto|scroll/, wr = /^tb|vertical/, xr = /msie|trident/i.test(me.navigator && me.navigator.userAgent), H = function(e) {
  return parseFloat(e || "0");
}, ce = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new br((n ? t : e) || 0, (n ? e : t) || 0);
}, Rt = ne({
  devicePixelContentBoxSize: ce(),
  borderBoxSize: ce(),
  contentBoxSize: ce(),
  contentRect: new Jt(0, 0, 0, 0)
}), Zt = function(e, t) {
  if (t === void 0 && (t = !1), Re.has(e) && !t)
    return Re.get(e);
  if (Qt(e))
    return Re.set(e, Rt), Rt;
  var n = getComputedStyle(e), r = st(e) && e.ownerSVGElement && e.getBBox(), o = !xr && n.boxSizing === "border-box", i = wr.test(n.writingMode || ""), s = !r && Et.test(n.overflowY || ""), c = !r && Et.test(n.overflowX || ""), a = r ? 0 : H(n.paddingTop), l = r ? 0 : H(n.paddingRight), f = r ? 0 : H(n.paddingBottom), p = r ? 0 : H(n.paddingLeft), b = r ? 0 : H(n.borderTopWidth), m = r ? 0 : H(n.borderRightWidth), v = r ? 0 : H(n.borderBottomWidth), u = r ? 0 : H(n.borderLeftWidth), d = p + l, h = a + f, g = u + m, w = b + v, O = c ? e.offsetHeight - w - e.clientHeight : 0, S = s ? e.offsetWidth - g - e.clientWidth : 0, R = o ? d + g : 0, M = o ? h + w : 0, A = r ? r.width : H(n.width) - R - S, B = r ? r.height : H(n.height) - M - O, F = A + d + S + g, N = B + h + O + w, L = ne({
    devicePixelContentBoxSize: ce(Math.round(A * devicePixelRatio), Math.round(B * devicePixelRatio), i),
    borderBoxSize: ce(F, N, i),
    contentBoxSize: ce(A, B, i),
    contentRect: new Jt(p, a, A, B)
  });
  return Re.set(e, L), L;
}, en = function(e, t, n) {
  var r = Zt(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case ge.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case ge.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Er = /* @__PURE__ */ function() {
  function e(t) {
    var n = Zt(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = ne([n.borderBoxSize]), this.contentBoxSize = ne([n.contentBoxSize]), this.devicePixelContentBoxSize = ne([n.devicePixelContentBoxSize]);
  }
  return e;
}(), tn = function(e) {
  if (Qt(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Rr = function() {
  var e = 1 / 0, t = [];
  te.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var c = [];
      s.activeTargets.forEach(function(l) {
        var f = new Er(l.target), p = tn(l.target);
        c.push(f), l.lastReportedSize = en(l.target, l.observedBox), p < e && (e = p);
      }), t.push(function() {
        s.callback.call(s.observer, c, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, Tt = function(e) {
  te.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (tn(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Tr = function() {
  var e = 0;
  for (Tt(e); pr(); )
    e = Rr(), Tt(e);
  return vr() && gr(), e > 0;
}, $e, nn = [], Sr = function() {
  return nn.splice(0).forEach(function(e) {
    return e();
  });
}, Or = function(e) {
  if (!$e) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Sr();
    }).observe(n, r), $e = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  nn.push(e), $e();
}, kr = function(e) {
  Or(function() {
    requestAnimationFrame(e);
  });
}, ke = 0, zr = function() {
  return !!ke;
}, Cr = 250, Ar = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, St = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], Ot = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Ve = !1, Mr = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Cr), !Ve) {
      Ve = !0;
      var r = Ot(t);
      kr(function() {
        var o = !1;
        try {
          o = Tr();
        } finally {
          if (Ve = !1, t = r - Ot(), !zr())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Ar);
    };
    document.body ? n() : me.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), St.forEach(function(n) {
      return me.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), St.forEach(function(n) {
      return me.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Je = new Mr(), kt = function(e) {
  !ke && e > 0 && Je.start(), ke += e, !ke && Je.stop();
}, Lr = function(e) {
  return !st(e) && !yr(e) && getComputedStyle(e).display === "inline";
}, Br = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || ge.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = en(this.target, this.observedBox, !0);
    return Lr(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Pr = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Te = /* @__PURE__ */ new WeakMap(), zt = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Se = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Pr(t, n);
    Te.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Te.get(t), i = o.observationTargets.length === 0;
    zt(o.observationTargets, n) < 0 && (i && te.push(o), o.observationTargets.push(new Br(n, r && r.box)), kt(1), Je.schedule());
  }, e.unobserve = function(t, n) {
    var r = Te.get(t), o = zt(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && te.splice(te.indexOf(r), 1), r.observationTargets.splice(o, 1), kt(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Te.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), Ct = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Se.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!xt(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Se.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!xt(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Se.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Se.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const Be = /* @__PURE__ */ new WeakMap();
function Dr(e) {
  for (let t = 0, n = e.length; t < n; ++t) {
    const r = e[t], o = Be.get(r.target);
    typeof o == "function" && o(r);
  }
}
const rn = new (D && window.ResizeObserver || Ct)(
  Dr
);
function We(e, t) {
  Be.set(e, t), rn.observe(e);
}
function on(e) {
  Be.has(e) && (rn.unobserve(e), Be.delete(e));
}
function ao() {
  return {
    observeResize: We,
    unobserveResize: on
  };
}
const sn = z(!1), Fr = W(() => sn.value), de = "__rtl_observer__";
function _r() {
  return D && !document.querySelector(`#${de}`) && Nr(), { isRtl: Fr };
}
function Nr() {
  if (!D)
    return;
  const e = document.createElement("style"), t = `#${de} { width: 1px } html.rtl #${de}, html[dir='rtl'] #${de} { width: 2px }`;
  e.textContent = t, document.head.appendChild(e);
  const n = document.createElement("div");
  n.id = de, n.role = "none", n.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", We(n, () => {
    D && (sn.value = document.documentElement.classList.contains("rtl") || document.documentElement.getAttribute("dir") === "rtl");
  }), document.body.appendChild(n);
}
const lo = Object.freeze([
  "top",
  "top-start",
  "top-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end",
  "right",
  "right-start",
  "right-end"
]);
function fo(e) {
  const { transfer: t, wrapper: n, isDrop: r = !1 } = e, o = e.reference ?? Ie(null), i = e.popper ?? Ie(null), s = e.arrow ?? Ie(null), c = z(T(e.placement)), a = z(""), l = e.isRtl ?? _r().isRtl;
  n && lt(() => {
    const u = T(n), d = T(i);
    u && (u.__transferElement = d);
  }), t != null && (J(
    () => T(t),
    (u) => {
      m(u), b();
    }
  ), m(T(t))), Ze(() => {
    requestAnimationFrame(() => {
      lt(p);
    });
  });
  let f;
  async function p() {
    if (!D)
      return;
    f == null || f();
    const u = T(o), d = T(i);
    if (!u || !d)
      return;
    const h = T(s), g = [jn()];
    if (r && g.push({
      name: "origin",
      fn({ placement: R, elements: M }) {
        const A = v(R);
        return A && (M.floating.style.transformOrigin = A), {};
      }
    }), e.offset) {
      let R = T(e.offset);
      Array.isArray(R) && (R = {
        mainAxis: R[1],
        crossAxis: R[0]
      }), g.push(Un(R));
    }
    if (e.shift) {
      let R = T(e.shift);
      typeof R == "boolean" && (R = {}), g.push(Gn(R));
    }
    h && g.push(Xn({ element: h })), g.push(Yn({ strategy: "escaped" }));
    const w = T(l) || !1, O = {
      middleware: g,
      placement: T(e.placement),
      platform: {
        ...Gt,
        isRTL: async () => w
      }
    }, S = async () => {
      const {
        x: R,
        y: M,
        placement: A,
        strategy: B,
        middlewareData: F
      } = await mr(u, d, O);
      if (T(o) !== u) {
        T(i) === d && Object.assign(d.style, {
          position: "",
          top: "",
          left: ""
        });
        return;
      }
      const N = {
        position: B,
        top: `${M}px`,
        left: `${R}px`
      };
      if (h)
        if (F.arrow) {
          const { x: L, y } = F.arrow;
          Object.assign(h.style, {
            top: y != null ? `${y}px` : "",
            left: L != null ? `${L}px` : ""
          });
        } else
          Object.assign(h.style, { top: "", left: "" });
      Object.assign(d.style, N), d.dataset.popperPlacement = A, c.value = A;
    };
    e.autoUpdate && (f = hr(u, d, S)), await S();
  }
  const b = () => new Promise((u) => {
    requestAnimationFrame(() => {
      p().then(u);
    });
  });
  function m(u) {
    a.value = typeof u == "boolean" ? u ? "body" : "" : u;
  }
  function v(u) {
    if (u !== "left" && u !== "right") {
      const [d, h] = u.split("-");
      return d === "bottom" || d !== "top" && h === "start" ? "center top" : "center bottom";
    }
  }
  return {
    wrapper: n,
    reference: o,
    popper: i,
    placement: c,
    transferTo: a,
    updatePopper: b
  };
}
const At = "__theme_style__", ze = "__theme_observer__", Mt = /* @__PURE__ */ new WeakMap();
function uo(e) {
  const t = z();
  if (D) {
    e = e || document.body;
    let n = Mt.get(e);
    n || (n = $r(t), e.appendChild(n), Mt.set(e, n));
  }
  return { theme: t };
}
const Pe = qe(/* @__PURE__ */ new Map()), Qe = /* @__PURE__ */ new Map();
J(Pe, () => {
  if (!D)
    return;
  Qe.clear();
  const e = document.head.querySelector(`#${At}`);
  e && document.head.removeChild(e);
  const t = document.createElement("style");
  let n = `.${ze} { width: 1px }`, r = 1;
  for (const [o, [i, s]] of Pe.entries())
    n += ` html.${i} .${ze}, .${s} .${ze} { width: ${++r}px }`, Qe.set(r, o);
  t.textContent = n, t.id = At, document.head.appendChild(t);
});
function Wr(e) {
  for (const t of e) {
    const {
      name: n,
      rootClass: r = n,
      varsClass: o = `vxp-theme-vars-${r}`
    } = typeof t == "string" ? { name: t } : t;
    Pe.set(n, [r, o]);
  }
}
function ho(e) {
  Pe.clear(), Wr(e);
}
let Ir = 0;
function Hr() {
  return `__theme_observer_${Ir++}__`;
}
function $r(e) {
  if (!D)
    return;
  const t = document.createElement("div");
  return t.id = Hr(), t.className = ze, t.role = "none", t.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", We(t, (n) => {
    var o;
    if (!D)
      return;
    const r = ((o = n.borderBoxSize) == null ? void 0 : o[0].inlineSize) ?? n.contentRect.width;
    e.value = Qe.get(r);
  }), t;
}
function Vr() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearTimeout(e[t]);
    });
  }), { timer: e };
}
function qr() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearInterval(e[t]);
    });
  }), { timer: e };
}
function Xr() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      cancelAnimationFrame(e[t]);
    });
  }), { timer: e };
}
function mo() {
  const { timer: e } = Vr(), { timer: t } = qr(), { timer: n } = Xr();
  return { timeout: e, interval: t, raf: n };
}
function po(e, t, n = 100) {
  let r;
  function o() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !0;
    }, n));
  }
  function i() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !1;
    }, n));
  }
  function s() {
    e.value === "click" && (t.value = !t.value);
  }
  return {
    handleTriggerEnter: o,
    handleTriggerLeave: i,
    handleTriggerClick: s
  };
}
function vo(e) {
  const {
    items: t,
    itemSize: n,
    itemFixed: r,
    idKey: o,
    defaultKeyAt: i,
    bufferSize: s = z(5),
    wrapper: c = z(null),
    autoResize: a = !0
  } = e, l = W(() => {
    const y = T(t), x = y.length, E = T(o), C = /* @__PURE__ */ new Map();
    for (let k = 0; k < x; ++k)
      C.set(y[k][E], k);
    return C;
  }), f = z(0), p = /* @__PURE__ */ new Map(), b = W(() => {
    const y = T(t), x = y.length, E = T(o), C = vn(x, T(n));
    for (let k = 0; k < x; ++k) {
      const j = y[k][E], Y = p.get(j);
      Y && C.add(k, Y);
    }
    return C;
  }), m = z(0), v = z(0), u = W(() => Math.max(
    b.value.boundIndex(v.value) - Math.max(T(s), 0),
    0
  )), d = W(() => {
    if (!f.value || f.value < 0)
      return [];
    const y = T(t), x = Math.min(
      b.value.boundIndex(v.value + f.value) + 1 + Math.max(T(s), 0),
      y.length
    );
    return y.slice(u.value, x);
  }), h = W(() => {
    m.value;
    const y = b.value.sum(), x = T(r);
    return {
      height: x ? `${y}px` : void 0,
      minHeight: x ? void 0 : `${y}px`,
      boxSizing: "content-box"
    };
  }), g = W(() => (m.value, {
    transform: `translate3d(0, ${b.value.sum(u.value)}px, 0)`
  }));
  if (a) {
    let y = P;
    const x = J(
      () => T(c),
      (E) => {
        y(), E && (We(E, S), y = () => {
          on(E), y = P;
        }, Xe(i) && B(i));
      },
      { immediate: !0, flush: "post" }
    );
    Q(() => {
      x(), y();
    });
  }
  function w() {
    const y = T(c);
    y && (v.value = y.scrollTop);
  }
  function O() {
    Sn(w);
  }
  function S(y) {
    dt(y.target) || y.contentRect.height === f.value || (f.value = y.contentRect.height);
  }
  function R(y, x) {
    var ct, at;
    if (T(r))
      return;
    const E = l.value.get(y), C = b.value, k = C.get(E), j = ((at = (ct = x.borderBoxSize) == null ? void 0 : ct[0]) == null ? void 0 : at.blockSize) ?? x.contentRect.height;
    if (j === k)
      return;
    if (dt(x.target)) {
      k && (C.add(E, -k), m.value++);
      return;
    }
    const Y = j - T(n), ue = j - k;
    if (Y ? p.set(y, Y) : p.delete(y), !ue)
      return;
    C.add(E, ue), m.value++;
    const Z = T(c);
    if (Z) {
      const cn = C.sum(E);
      Z.scrollTop > cn && Z.scrollBy(0, ue), v.value = Z.scrollTop;
    }
  }
  function M(y, x) {
    const E = T(c);
    E && E.scrollTo({
      behavior: x,
      top: y,
      left: 0
    });
  }
  function A(y, x) {
    const E = T(c);
    E && E.scrollBy({
      behavior: x,
      top: y,
      left: 0
    });
  }
  function B(y, x) {
    const E = l.value.get(y);
    E != null && F(E, x);
  }
  function F(y, x) {
    const E = T(c);
    E && E.scrollTo({
      behavior: x,
      top: b.value.sum(y),
      left: 0
    });
  }
  function N(y, x) {
    const E = T(c);
    if (!E)
      return;
    const C = b.value, k = E.scrollTop;
    if (C.sum(y) < k) {
      F(y, x);
      return;
    }
    const Y = E.offsetHeight, ue = k + Y, Z = C.sum(y + 1);
    Z > ue && M(Z - Y, x);
  }
  function L(y, x) {
    const E = l.value.get(y);
    E != null && N(E, x);
  }
  return {
    wrapper: c,
    indexMap: l,
    heightTree: b,
    startIndex: u,
    scrollOffset: v,
    visibleItems: d,
    listStyle: h,
    itemsStyle: g,
    handleScroll: O,
    handleResize: S,
    handleItemResize: R,
    scrollTo: M,
    scrollBy: A,
    scrollToKey: B,
    scrollToIndex: F,
    ensureIndexInView: N,
    ensureKeyInView: L
  };
}
export {
  _t as CLICK_OUTSIDE,
  Wr as addActiveThemes,
  Ur as createSlotRender,
  Gr as flatVNodes,
  dt as isHiddenElement,
  We as observeResize,
  Zr as pickToRefs,
  lo as placementWhileList,
  Jr as proxyExposed,
  Nt as queryOutsideHiddenElement,
  ho as setActiveThemes,
  on as unobserveResize,
  we as unrefElement,
  Yr as useClickOutside,
  Kr as useDisplay,
  eo as useFullScreen,
  to as useHover,
  no as useIntersection,
  V as useListener,
  ro as useManualRef,
  oo as useModifier,
  io as useMounted,
  so as useMoving,
  co as usePointer,
  fo as usePopper,
  Xr as useRaf,
  ao as useResize,
  _r as useRtl,
  qr as useSetInterval,
  Vr as useSetTimeout,
  uo as useTheme,
  mo as useTimerRecord,
  po as useTriggerHandler,
  vo as useVirtual,
  Qr as watchPauseable
};
//# sourceMappingURL=index.mjs.map
